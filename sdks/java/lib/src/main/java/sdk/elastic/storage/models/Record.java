package sdk.elastic.storage.models;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import sdk.elastic.storage.flatc.records.KeyValue;
import sdk.elastic.storage.flatc.records.RecordMeta;

/**
 * A record generally wraps a message. It is the basic unit of data in the stream.
 * DO NOT encode a record directly, because RecordMeta can only be generated by {@link RecordBatch}.
 * Note that data nodes store records with a whole {@link RecordBatch} instead of a single {@link Record}.
 */
public class Record {
    /**
     * The minimum length of an encoded record.
     */
    public static final int ENCODED_MIN_LENGTH = 8;
    /**
     * The id of the stream which this record belongs to.
     */
    private final long streamId;
    /**
     * The offset of this record in the stream.
     */
    private final long offset;
    /**
     * The timestamp of this record.
     */
    private final long timestamp;
    /**
     * The headers of this record. Headers store the commonly used attributes of Record, which are unrelated to any specific message protocol.
     */
    private final Headers headers;
    /**
     * The properties of this record. Properties store the attributes of Record, which may be related to the message protocol.
     */
    private final Map<String, String> properties;
    /**
     * The body of this record. Body stores the message payload.
     */
    private final ByteBuffer body;

    public Record(long streamId, long offset, long timestamp, Headers headers, Map<String, String> properties,
        ByteBuffer body) {
        this.streamId = streamId;
        this.offset = offset;
        this.timestamp = timestamp;
        this.headers = headers;
        this.properties = properties;
        this.body = body;
    }

    public Record(long streamId, long offset, Headers headers, Map<String, String> properties, ByteBuffer body) {
        this(streamId, offset, System.currentTimeMillis(), headers, properties, body);
    }

    public Record(ByteBuffer buffer, long streamId, long baseOffset, long baseTimestamp) {
        int metaLength = buffer.getInt();
        int bodyLength = buffer.getInt();

        assert buffer.remaining() >= metaLength + bodyLength;
        byte[] metaBytes = new byte[metaLength];
        buffer.get(metaBytes);
        RecordMeta meta = RecordMeta.getRootAsRecordMeta(ByteBuffer.wrap(metaBytes));

        this.streamId = streamId;
        this.offset = baseOffset + meta.offsetDelta();
        this.timestamp = baseTimestamp + meta.timestampDelta();
        if (meta.headersVector() != null && meta.headersLength() > 0) {
            this.headers = new Headers();
            for (int i = 0; i < meta.headersLength(); i++) {
                KeyValue keyValue = meta.headers(i);
                HeaderKey key = HeaderKey.valueOf(keyValue.key());
                this.headers.addHeader(key, keyValue.value());
            }
        } else {
            this.headers = null;
        }
        if (meta.propertiesVector() != null && meta.propertiesLength() > 0) {
            this.properties = new HashMap<>();
            for (int i = 0; i < meta.propertiesLength(); i++) {
                KeyValue keyValue = meta.properties(i);
                this.properties.put(keyValue.key(), keyValue.value());
            }
        } else {
            this.properties = null;
        }

        byte[] bodyBytes = new byte[bodyLength];
        buffer.get(bodyBytes);
        this.body = ByteBuffer.wrap(bodyBytes);
    }

    public long getOffset() {
        return offset;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public ByteBuffer getBody() {
        return body;
    }

    public Headers getHeaders() {
        return headers;
    }

    public Map<String, String> getProperties() {
        return properties;
    }

    /**
     * Check if two records are equivalent, i.e., they have equal components except for offset.
     * @param other the other record to compare with.
     * @return true if two records are equivalent, false otherwise.
     */
    public boolean equivalent(Record other) {
        return new org.apache.commons.lang3.builder.EqualsBuilder()
            .append(this.streamId, other.streamId)
            .append(this.timestamp, other.timestamp)
            .append(this.headers, other.headers)
            .append(this.properties, other.properties)
            .append(this.body.duplicate(), other.body.duplicate())
            .isEquals();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        Record rhs = (Record) obj;
        return this.offset == rhs.offset &&
            equivalent(rhs);
    }

    @Override
    public int hashCode() {
        return new org.apache.commons.lang3.builder.HashCodeBuilder()
            .append(this.offset)
            .append(this.streamId)
            .append(this.timestamp)
            .append(this.headers)
            .append(this.properties)
            .append(this.body)
            .toHashCode();
    }
}
