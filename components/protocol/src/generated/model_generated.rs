// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SYSTEM_KEYS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SYSTEM_KEYS: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SYSTEM_KEYS: [SystemKeys; 3] = [
  SystemKeys::Tag,
  SystemKeys::Keys,
  SystemKeys::RecordId,
];

/// Enum values should only ever be added. Never remove or renumber them.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SystemKeys(pub i8);
#[allow(non_upper_case_globals)]
impl SystemKeys {
  /// The tag marks the record, is used to filter records in server side.
  pub const Tag: Self = Self(0);
  /// The list of index keys for records.
  pub const Keys: Self = Self(1);
  /// The unique id of the record. It's not neccessary to be unique in the whole cluster.
  pub const RecordId: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Tag,
    Self::Keys,
    Self::RecordId,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Tag => Some("Tag"),
      Self::Keys => Some("Keys"),
      Self::RecordId => Some("RecordId"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SystemKeys {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SystemKeys {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SystemKeys {
    type Output = SystemKeys;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SystemKeys {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SystemKeys {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SystemKeys {}
pub enum BatchRecordMetaOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Don't delete any field from the schema once released.
/// Asign a id for each filed to keep compatibility easily.
pub struct BatchRecordMeta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BatchRecordMeta<'a> {
  type Inner = BatchRecordMeta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BatchRecordMeta<'a> {
  pub const VT_MAGIC: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 6;
  pub const VT_BASE_OFFSET: flatbuffers::VOffsetT = 8;
  pub const VT_LAST_OFFSET_DELTA: flatbuffers::VOffsetT = 10;
  pub const VT_FIRST_TIMESTAMP: flatbuffers::VOffsetT = 12;
  pub const VT_MAX_TIMESTAMP: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BatchRecordMeta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BatchRecordMetaArgs
  ) -> flatbuffers::WIPOffset<BatchRecordMeta<'bldr>> {
    let mut builder = BatchRecordMetaBuilder::new(_fbb);
    builder.add_max_timestamp(args.max_timestamp);
    builder.add_first_timestamp(args.first_timestamp);
    builder.add_base_offset(args.base_offset);
    builder.add_last_offset_delta(args.last_offset_delta);
    builder.add_attributes(args.attributes);
    builder.add_magic(args.magic);
    builder.finish()
  }


  /// The record format version of this record batch.
  #[inline]
  pub fn magic(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(BatchRecordMeta::VT_MAGIC, Some(0)).unwrap()}
  }
  /// The attributes of this record batch. Each bit is used to indicate a specific attribute.
  #[inline]
  pub fn attributes(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(BatchRecordMeta::VT_ATTRIBUTES, Some(0)).unwrap()}
  }
  /// The base offset of the batch record, also is the logical offset of the first record.
  #[inline]
  pub fn base_offset(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BatchRecordMeta::VT_BASE_OFFSET, Some(0)).unwrap()}
  }
  /// The delta value between the last offset and the base offset. 
  #[inline]
  pub fn last_offset_delta(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(BatchRecordMeta::VT_LAST_OFFSET_DELTA, Some(0)).unwrap()}
  }
  /// The create timestap of the first record in this batch.
  #[inline]
  pub fn first_timestamp(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BatchRecordMeta::VT_FIRST_TIMESTAMP, Some(0)).unwrap()}
  }
  /// The max timestamp among all records contained in this batch.
  #[inline]
  pub fn max_timestamp(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BatchRecordMeta::VT_MAX_TIMESTAMP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BatchRecordMeta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("magic", Self::VT_MAGIC, false)?
     .visit_field::<i8>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<i64>("base_offset", Self::VT_BASE_OFFSET, false)?
     .visit_field::<i32>("last_offset_delta", Self::VT_LAST_OFFSET_DELTA, false)?
     .visit_field::<i64>("first_timestamp", Self::VT_FIRST_TIMESTAMP, false)?
     .visit_field::<i64>("max_timestamp", Self::VT_MAX_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct BatchRecordMetaArgs {
    pub magic: i8,
    pub attributes: i8,
    pub base_offset: i64,
    pub last_offset_delta: i32,
    pub first_timestamp: i64,
    pub max_timestamp: i64,
}
impl<'a> Default for BatchRecordMetaArgs {
  #[inline]
  fn default() -> Self {
    BatchRecordMetaArgs {
      magic: 0,
      attributes: 0,
      base_offset: 0,
      last_offset_delta: 0,
      first_timestamp: 0,
      max_timestamp: 0,
    }
  }
}

pub struct BatchRecordMetaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BatchRecordMetaBuilder<'a, 'b> {
  #[inline]
  pub fn add_magic(&mut self, magic: i8) {
    self.fbb_.push_slot::<i8>(BatchRecordMeta::VT_MAGIC, magic, 0);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: i8) {
    self.fbb_.push_slot::<i8>(BatchRecordMeta::VT_ATTRIBUTES, attributes, 0);
  }
  #[inline]
  pub fn add_base_offset(&mut self, base_offset: i64) {
    self.fbb_.push_slot::<i64>(BatchRecordMeta::VT_BASE_OFFSET, base_offset, 0);
  }
  #[inline]
  pub fn add_last_offset_delta(&mut self, last_offset_delta: i32) {
    self.fbb_.push_slot::<i32>(BatchRecordMeta::VT_LAST_OFFSET_DELTA, last_offset_delta, 0);
  }
  #[inline]
  pub fn add_first_timestamp(&mut self, first_timestamp: i64) {
    self.fbb_.push_slot::<i64>(BatchRecordMeta::VT_FIRST_TIMESTAMP, first_timestamp, 0);
  }
  #[inline]
  pub fn add_max_timestamp(&mut self, max_timestamp: i64) {
    self.fbb_.push_slot::<i64>(BatchRecordMeta::VT_MAX_TIMESTAMP, max_timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BatchRecordMetaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BatchRecordMetaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BatchRecordMeta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BatchRecordMeta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BatchRecordMeta");
      ds.field("magic", &self.magic());
      ds.field("attributes", &self.attributes());
      ds.field("base_offset", &self.base_offset());
      ds.field("last_offset_delta", &self.last_offset_delta());
      ds.field("first_timestamp", &self.first_timestamp());
      ds.field("max_timestamp", &self.max_timestamp());
      ds.finish()
  }
}
pub enum PropertyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Property<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Property<'a> {
  type Inner = Property<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Property<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Property { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PropertyArgs<'args>
  ) -> flatbuffers::WIPOffset<Property<'bldr>> {
    let mut builder = PropertyBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Property::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Property::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Property<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct PropertyArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PropertyArgs<'a> {
  #[inline]
  fn default() -> Self {
    PropertyArgs {
      key: None,
      value: None,
    }
  }
}

pub struct PropertyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PropertyBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropertyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PropertyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Property<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Property");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum HeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
  type Inner = Header<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Header<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Header { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<Header<'bldr>> {
    let mut builder = HeaderBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> SystemKeys {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SystemKeys>(Header::VT_KEY, Some(SystemKeys::Tag)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Header<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<SystemKeys>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct HeaderArgs<'a> {
    pub key: SystemKeys,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    HeaderArgs {
      key: SystemKeys::Tag,
      value: None,
    }
  }
}

pub struct HeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: SystemKeys) {
    self.fbb_.push_slot::<SystemKeys>(Header::VT_KEY, key, SystemKeys::Tag);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Header<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Header");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum RecordMetaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RecordMeta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RecordMeta<'a> {
  type Inner = RecordMeta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RecordMeta<'a> {
  pub const VT_OFFSET_DELTA: flatbuffers::VOffsetT = 4;
  pub const VT_TIMESTAMP_DELTA: flatbuffers::VOffsetT = 6;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 8;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RecordMeta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RecordMetaArgs<'args>
  ) -> flatbuffers::WIPOffset<RecordMeta<'bldr>> {
    let mut builder = RecordMetaBuilder::new(_fbb);
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.headers { builder.add_headers(x); }
    builder.add_timestamp_delta(args.timestamp_delta);
    builder.add_offset_delta(args.offset_delta);
    builder.finish()
  }


  #[inline]
  pub fn offset_delta(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RecordMeta::VT_OFFSET_DELTA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp_delta(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RecordMeta::VT_TIMESTAMP_DELTA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header>>>>(RecordMeta::VT_HEADERS, None)}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(RecordMeta::VT_PROPERTIES, None)}
  }
}

impl flatbuffers::Verifiable for RecordMeta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("offset_delta", Self::VT_OFFSET_DELTA, false)?
     .visit_field::<i32>("timestamp_delta", Self::VT_TIMESTAMP_DELTA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Header>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .finish();
    Ok(())
  }
}
pub struct RecordMetaArgs<'a> {
    pub offset_delta: i32,
    pub timestamp_delta: i32,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
}
impl<'a> Default for RecordMetaArgs<'a> {
  #[inline]
  fn default() -> Self {
    RecordMetaArgs {
      offset_delta: 0,
      timestamp_delta: 0,
      headers: None,
      properties: None,
    }
  }
}

pub struct RecordMetaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RecordMetaBuilder<'a, 'b> {
  #[inline]
  pub fn add_offset_delta(&mut self, offset_delta: i32) {
    self.fbb_.push_slot::<i32>(RecordMeta::VT_OFFSET_DELTA, offset_delta, 0);
  }
  #[inline]
  pub fn add_timestamp_delta(&mut self, timestamp_delta: i32) {
    self.fbb_.push_slot::<i32>(RecordMeta::VT_TIMESTAMP_DELTA, timestamp_delta, 0);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Header<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecordMeta::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecordMeta::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecordMetaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RecordMetaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RecordMeta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RecordMeta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RecordMeta");
      ds.field("offset_delta", &self.offset_delta());
      ds.field("timestamp_delta", &self.timestamp_delta());
      ds.field("headers", &self.headers());
      ds.field("properties", &self.properties());
      ds.finish()
  }
}
